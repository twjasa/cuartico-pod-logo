<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>My first three.js app</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <script src="js/three.js"></script>
  <script>
    // Our Javascript will go here.
    const colors = {
      orange: `#ff6b43`,
      beige: `#feeed5`,
      darkBlue: `#002329`,
      lightBlue: `#00bdfd`
    }
    const scene = new THREE.Scene()
    const width = 5
    const height = width * (window.innerHeight / window.innerWidth)
    const camera = new THREE.OrthographicCamera(
      width / -2,
      width / 2,
      height / 2,
      height / -2,
      1,
      100
    )

    const renderer = new THREE.WebGLRenderer()
    renderer.setSize(window.innerWidth, window.innerHeight)
    document.body.appendChild(renderer.domElement)

    const boxGeometry = new THREE.BoxGeometry(1, 1, 1)
    const material = [
      new THREE.MeshBasicMaterial({ // front right side
        color: colors.orange,
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({ // back left side
        color: colors.lightBlue,
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({ // top
        color: colors.orange,
        transparent: true, opacity: 0,
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({ // bottom
        color: colors.darkBlue,
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({ // front left side 
        color: colors.orange,
        transparent: true, opacity: 0,
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({ // back right side
        color: colors.lightBlue,
        transparent: true, opacity: 0,
        side: THREE.DoubleSide
      }),
    ]
    const meshBox = new THREE.Mesh(boxGeometry, material)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.1)
    const light = new THREE.DirectionalLight(0xffffff, 2, 119)
    light.position.set(1, 0.4, 0.1)
    //TAPA
    const prismGeometry = new THREE.BufferGeometry()
    const prismVertices = new Float32Array([
      -0.5, 0.5, 0.5, // 1
      0.5, 0.5, 0.5,  // 2
      0, 0.8, 0.5, // 3

      -0.5, 0.5, -0.5, // 4
      0.5, 0.5, -0.5, // 5
      0, 0.8, -0.5, // 6
    ])
    const indices = [
      0, 1, 2, // Top
      5, 4, 3, // Bottom
      3, 1, 0, // Back
      1, 3, 4, // Back
      0, 2, 3, // Left
      5, 3, 2, // Left
      4, 2, 1, // Right
      2, 4, 5, // Right
    ]
    prismGeometry.setAttribute('position', new THREE.BufferAttribute(prismVertices, 3))
    prismGeometry.setIndex(indices)

    prismGeometry.computeVertexNormals()

    prismGeometry.clearGroups()
    prismGeometry.addGroup(1, 3, 0)
    prismGeometry.addGroup(3, 6, 1)
    prismGeometry.addGroup(6, 12, 2)
    prismGeometry.addGroup(12, 18, 3)
    prismGeometry.addGroup(18, 24, 4)
    const prismMaterial = [
      new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: 0,
      }),
      new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: 0,
      }),
      new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: 0,
      }),
      new THREE.MeshBasicMaterial({
        color: colors.darkBlue,
        side: THREE.DoubleSide
      }),
      new THREE.MeshBasicMaterial({
        color: colors.beige,
        side: THREE.DoubleSide
      })
    ]
    const prismMesh = new THREE.Mesh(prismGeometry, prismMaterial) //
    ///////////
    //LID
    const lidGeometry = new THREE.PlaneGeometry(1, 0.3, 1, 2)
    const lidMaterial = new THREE.MeshBasicMaterial({ color: colors.lightBlue, side: THREE.DoubleSide })
    const lid = new THREE.Mesh(lidGeometry, lidMaterial)
    lid.position.set(0, 0.95, 0)
    lid.rotation.set(0, (90 / 180) * Math.PI, 0)
    //////

    scene.add(lid)
    scene.add(prismMesh)
    scene.add(ambientLight)
    scene.add(light)
    scene.add(meshBox)

    camera.position.set(4, 4, 4)
    camera.lookAt(meshBox.position)

    const canvas = renderer.domElement
    canvas.addEventListener("mousemove", onMouseMove)

    function onMouseMove(event) {
      meshBox.rotation.y += event.movementX * 0.006
      prismMesh.rotation.y += event.movementX * 0.006
      lid.rotation.y += event.movementX * 0.006
      // prismMesh.rotation.x += event.movementY * 0.006
    }

    function animate() {
      requestAnimationFrame(animate)
      // meshBox.rotation.x += 0.01;
      // meshBox.rotation.y += 0.01;
      renderer.render(scene, camera)
    }
    animate();

  </script>
</body>

</html>